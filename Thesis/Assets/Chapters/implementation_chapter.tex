\chapter{Implementation}
\gjor{Skriv opp Worklog-materiale (under ``muy bien so far''-bokmerket) dandert i henhold til gode master-theses}


% Introducing the Chapter
This chapter gives an overview of the developed musical multi-robot system. The main goal of the implemented system is to allow for a multi-robot (musical) collective to interact with each other in order to achieve emergent and co-ordinating/co-operative behaviour—synchronization specifically in our case—with varying degrees of difficulty and certainty in the environment and communication. More specifically, the goal with the design is to enable the robot collective to achieve so-called \textit{harmonic synchronization} within a relatively short time. What is meant by \textit{harmonic synchronization} will be expounded in Subsection \ref{subsec:harmonic_synchrony}. These goals firstly require of the agents/nodes the modelling of oscillators with their properties, like phase and frequency, as explained further in Subsection \ref{subsec:node}. To allow for interaction and communication between the agents, mechanisms so that the agents can transmit "fire"-signals, as well as listen for other agents's "fire"-signals, is necessary as well, and is presented in Subsection \ref{subsec:fire_signal}.



% Om baselinen (hva jeg baserer min implementasjon på, forskjellig fra mitt eget bidrag).
% Introducing the System:
\section{The baseline: Achieving Decentralized Harmonic Synchronization in (Oscillators $\vee$ Musical Robot Collectives)}
\label{sec:baseline}
	Envision that we have a multi-agent collective scenario consisting of musical robots modelled as oscillators, solely communicating through brief ``fire''-like audio-signals|greatly inspired by K. Nymoen et al.'s approach for achieving \textit{decentralized harmonic synchronization in mobile music systems} \cite{nymoen_synch}. These agents are initially not synchronized in their firing of audio-signals, but as time goes, they are entraining to synchronize to each other by adjusting their phases and frequencies when or after hearing each other's audio-signals. An illustration of this is given in Figure \ref{fig:initial}.

	% First Intro-illustration figure to easily get a quick idea of what the system/design does/consists of:
	\begin{figure}[h]
		\centering
			\begin{subfigure}[t]{.5\textwidth}
				\centering\captionsetup{width=.9\linewidth}%
				\includegraphics[width=0.9\linewidth]{Assets/Figures/IntroUnsynch.jpg}
				\caption{The agents firing asynchronously at first. Here, only the two Dr. Squiggles with red tentacles are firing simultaneously, but the rest are not.}
				\label{fig:initial:unsynch}
			\end{subfigure}%
			\begin{subfigure}[t]{.5\textwidth}
				\centering\captionsetup{width=.9\linewidth}%
				\includegraphics[width=0.9\linewidth]{Assets/Figures/IntroSynch.jpg}
				\caption{Seconds later, after having listened to each other's fire-event signals and adapted themselves accordingly, the agents are here firing synchronously.}
				\label{fig:initial:synch}
			\end{subfigure}
		\caption{Decentralized Synchronization of phases achieved in a musical robot collective, consisting of M. J. Krzyzaniak and RITMO's Dr. Squiggles.}
		\label{fig:initial}
	\end{figure}

	These aforementioned audio-signals to be expounded further in Subsection \ref{subsec:fire_signal}, also referred to as ``fire''-signals, are transmitted whenever an agent's oscillator \textit{peaks} (i.e. after its cycle or period is finished, having phase $\phi(t)=1$)|or actually every second \textit{peak}, due to the target system goal of \textit{harmonic synchrony}. All agents have the ability to listen for such transmitted ``fire''-signals from their neighbours, which they then will use as a trigger to adjust themselves according to some well-designed update-functions to be elaborated in Subsection \ref{subsec:update_functions}.

	% INCLUDE? See 'Relevant MSc-thesis Concerns'.
		% % Phase-/time-plot Figure with two Subplots. Subplot 1: phase-/time-plot when oscillators are unsynchronized. Subplot 2: phase-/time-plot when oscillators are synchronized
		% \begin{figure}[h]
			% \centering
				% \begin{subfigure}[t]{.5\textwidth}
					% \centering\captionsetup{width=.9\linewidth}%
					% \includegraphics[width=0.9\linewidth]{Assets/Figures/phases_unsynched.png}
					% \caption{Oscillators are initially not (phase-) synchronized.}
					% \label{fig:phases_unsynched}
				% \end{subfigure}%
				% \begin{subfigure}[t]{.5\textwidth}
					% \centering\captionsetup{width=.9\linewidth}%
					% \includegraphics[width=0.9\linewidth]{Assets/Figures/phases_synched.png}
					% \caption{Oscillators are now, seconds later, (phase-) synchronized.}
					% \label{fig:phases_synched}
				% \end{subfigure}
			% \caption{Phase-plots for the agents}
			% \label{fig:initial}
		% \end{figure}



	% Sub-Introducing the System:
	
	% Om den enkelte noden/agenten med alle egenskaper den har osv.
	\subsection{The Node: the musical robot individual}
	\label{subsec:node}
		\besk{Om den enkelte noden/agenten med alle egenskaper den har osv. (som f.eks. en oscillator-komponent (jf. I.A., III.Intro., og 'Implementation' i Nymoens Firefly-paper))}


	% Om kommunikasjonen til agentene: audio-/``fire''-signalet
	\subsection{Robot communication: the ``fire''-signal}
	\label{subsec:fire_signal}
		\begin{itemize}
			\item Short and impulsive audio sound/signal, representing a node's phase-climax and ``fire''-/``flash''-event.
			\item The only means of communication.
			\item Stigmergic co-ordination/communication.
			\item Facilitating PCO (pulse-coupled oscillators), different from phase-coupled oscillators with their differences.
		\end{itemize}

	\gjor{Sjekk oppsummeringen av Nymoen-paperet i Essayet}
	

	% Om target-staten til systemet: harmonisk synkroni
	\subsection{System target state: Harmonic Synchrony}
	\label{subsec:harmonic_synchrony}
		\begin{itemize}
			\item The goal and target state of the system
			\item All agents/nodes having integer-relation frequencies (between each other), so that given a fundamental frequency $\omega_{i,0}$ for the agent $i$ with the lowest frequency in the collective — all other agents have "legal" harmonic frequencies; meaning, all nodes have frequencies in the \tcol{mengde} $\omega_{i,0} \cdot 2^{\mathbb{N}_0}$.
			
		\end{itemize}
	
	
	% Om Update-functions for frekvens- og fase-oppdateringene
	\subsection{Update/Adjustment functions: Phase- \& Frequency-Adjustment}
	\label{subsec:update_functions}
	
	Musical agents's phases get updated/adjusted immediately as ``fire''-/``flash''-events are perceived, whereas agents's frequencies do not get updated until the end of their oscillator-cycle (i.e. when having a phase-climax $\phi(t)=1$). So-called H-values, used for frequency-adjustment/-updating at phase-climaxes, are however calculated and accumulated when agents are perceiving a ``fire''-/``flash''-event.
	
		\subsubsection{Phase Adjustment}
		\label{subsubsec:phase_adj}
			If we first assume constant and equal oscillator-frequencies in our agents, we can take a look at how the agents adjust their|initially random|phases in order to synchronize to each other. This is in contrast to the case in \ref{subsubsec:freq_adj} where heterogenous, often randomly initialized, oscillator-frequencies in the musical agents are implemented and utilized.
			
			The goal state of the agents is now to fire/flash more or less simultaneously, after having starting firing/flashing at random initially.
			
			Two approaches to achieve this were attempted in Unity, as presented in Nymoen et al.'s ``\textit{Firefly-paper}'' \cite{nymoen_synch}:
			
			\myparagraph{1) Mirollo-Strogatz's ``standard'' Phase Adjustment}
			
			\begin{figure}[h]
				\centering
				\includegraphics[width=0.9\linewidth]{Assets/Figures/MirolloStrogatzPhaseAdjustment.pdf}
				\caption{``Standard'' Phase-Adjustment with Mirrollo-Strogatz's approach}
				\label{fig:strog_phase}
			\end{figure}
			
			Each musical node updates its phase $\phi$ accoring to the \textbf{phase update function \eqref{strog_phase}} when hearing a ``fire''-event from one of the other musical nodes:
			
			\begin{equation}\label{strog_phase}
			P(\phi) = (1 + \alpha)\phi	,
			\end{equation}
			
			where ``\textit{$\alpha$ is the pulse coupling constant, denoting the strength between nodes}'' \cite{nymoen_synch}. So, if $\alpha = 0.1$ e.g., then a musical node's new and updated phase, immediately after hearing a ``fire''-signal from another node, will be equal to $P(\phi) = (1 + 0.1)\phi = 1.1\phi$. 110\% of its old phase $\phi$, that is. Hence, and in this way, the node would be ``pushed'' to fire sooner than it would otherwise. An illustration of this is given in Figure \ref{fig:strog_phase}.
			
			
			\myparagraph{2) Nymoen et al.'s Bi-Directional Phase Shifts}
			
			\begin{figure}[h]
				\centering
				\includegraphics[width=0.9\linewidth]{Assets/Figures/NymoenPhaseAdjustment.pdf}
				\caption{Bi-directional Phase-Adjustment with K. Nymoen et al.'s approach}
				\label{fig:nymoen_phase}
			\end{figure}
			
			This Phase-adjustment, as in Figure \ref{fig:nymoen_phase}, works very similarly to the Phase-adjustment performed in the \textbf{\textit{Mirollo-Strogatz}} approach; The only difference being that now, nodes update their phase with the slightly more complex \textbf{phase update function \eqref{nymoen_phase}} when hearing a ``fire''-event from one of the other musical nodes — allowing for both larger, but also smaller, updated phases:
			
			\begin{equation}
			\label{nymoen_phase}
				P(\phi) = \phi - \alpha \cdot sin(2\pi\phi) \cdot | sin(2\pi\phi) |
			\end{equation}
			
			The fact that new and updated phases can both be larger, but also smaller, compared to the old phases, is exactly what's meant by the Phase-adjustment being \textbf{\textit{Bi-Directional}}, or as the authors call it in the paper as using ``\textit{both excitatory and inhibitory phase couplings between oscillators}'' \cite{nymoen_synch}.
			
			The effects then of adjusting phases, upon hearing ``fire''-events, according to this newest update-function \eqref{nymoen_phase} are that the nodes's phases now get decreased if $\phi$ is lower than 0.5, increased if $\phi$ is higher than 0.5, and neither—at least almost—if the phases are close to $0.5 = \frac{1}{2}$. This is due to the negative and positive sign of the sinewave-component in Equation \eqref{nymoen_phase}, as well as the last attenuating factor in it of $| sin(2\pi\phi) | \approx | sin(2\pi \frac{1}{2}) | = | sin(\pi) | = | 0 | = 0.$
		
		
		\subsubsection{Frequency Adjustment}
		\label{subsubsec:freq_adj}
				\gjor{Presenter hva Frequency-adjustment er, bygg opp fremgangsmåten på hvordan man oppnår Frequency-adjustment (som i Worklog'en, og Mattermost-chatten med Kyrre evt.) | med passende figurer og illustrasjoner}
				
			Now over to the slightly more complex issue of synchronizing frequencies. We introduce randomly initialized, non-constant, and heterogenous oscillator-frequencies in our musical agents|allowing in the music collective the playing of rhythmic patterns like \tcol{doubles, fourths, eights} etc.
			
			This approach to Frequency Adjustment stands in contrast to previous approaches to synchronization in oscillators \tcol{cite(fixed\_freqs, fixed\_range\_freqs)} where the oscillators's frequencies are either equal and fixed, or where frequencies are bound to initialize and stay within a fixed interval/range.
			
			The goal state now will not be exactly equal frequencies and phases, but rather the goal state of \textit{harmonic synchrony}, as expounded in Subsection \ref{subsec:harmonic_synchrony}.
			
			In order to achieve this goal of \textit{harmonic synchrony} in conjunction with|or rather through|frequency adjustment, we have to go through a few steps to build a sophisticated enough update-function able to help us achieve this.
			
			
			% Om epsilon(n):
			\myparagraph{Step 1: The ``in/out-of synch'' Error-Measurement/-Score, $\epsilon(\phi(t))$}
			
			Describing the error measurements at the n-th ``fire''-event, we introduce an Error Measurement function.
			
			The Error Measurement function \eqref{error_measurement}, plotted in Figure \ref{fig:error_measurement}, is calculated immediately by each agent $i$, having phase $\phi_i(t)$, when a ``fire''-event signal from another agent is detected by agent $i$ at time $t$.
			
			\begin{equation}
			\label{error_measurement}
				\epsilon(\phi_i(t)) = sin^2(\pi\phi_i(t))
			\end{equation} \nl
			
			\begin{figure}[h!]
				\centering
				\includegraphics[width=0.8\linewidth]{Assets/Figures/PhaseErrorFunction.pdf}
				\caption{Error Measurement \eqref{error_measurement} plotted as a function of Phase}
				\label{fig:error_measurement}
			\end{figure}
			
			As we can see from this Error-Function, the error-score is close to 0 when the agent's phase $\phi_i(t)$ is itself close to 0 or 1 (i.e. the agent either just fired/flashed, or is about to fire/flash very soon). The error-score is the largest when an agent perceives a ``fire''-signal while being half-way through its own phase (i.e. having phase $\phi(t)=0.5$).
			
			This Error-Measurement/-Score forms the basis and fundament for the first component of Self-awareness, being the \textit{self-assessed synchrony-score} $s(n)$.
			
			% Om s(n):
			\myparagraph{Step 2: The first Self-awareness component, s(n)}
			This aforementioned self-assessed synchrony-score, $s(n)$, is in fact simply the median of a list \tcol{(was originally in K. Nymoen et al.'s approach a running median filter over the discrete error measurement function)} containing \textit{m} Error-scores $\epsilon$. Such a list is easily implemented in C\# by declaring a List$<$float$>$ called \textit{errorBuffer} e.g. (i.e. \textit{errorBuffer} is a list containing floating point values):
			
			\begin{equation}
			\label{error_buffer}
				errorBuffer = \{\epsilon(n), \epsilon(n-1), ... , \epsilon(n-m)\},
			\end{equation} \nl
			
			then leading to:
			
			\begin{equation}
			\label{self_assessed_synch}
				\begin{array}{rrclcl}
				s(n) & = & median(errorBuffer) \\ 
				& = & median(\{\epsilon(n), \epsilon(n-1), ... , \epsilon(n-m)\}) \in [0, 1],
				\end{array}
			\end{equation} \nl
			
			where $n$ is the latest observed ``fire-event'', and $m$ is the number of the last observed ``fire''-events we would like to take into account when calculating the self-assessed synch-score.
			
			If we then have a high $s(n)$-score, it tells us that the median of the $k$ last error-scores is high, or in other words that we have mainly high error-scores — indicating that this agent is out of synch. Conversely, if we have a low $s(n)$-score, indicating mainly low error-scores for the agent — then we have an indication that the agent is in synch, hence leading to low error scores, and in turn low $s(n)$-scores. 
			
			In other words, we then have a way for each agent to assess themselves how much in or out of synch they believe they are compared to the rest of the agents. This is then the first degree/aspect of \tcol{(public?)} Self-awareness in the design.
			
			% Om rho(n):
			\myparagraph{Step 3: Frequency Update Amplitude- \& Sign-factor, $\rho(n)$}
			
			Describing the amplitude and sign of the frequency-modification of the n-th ``fire-event'' received. It is used to say something about in which direction, and in how much, the frequency should be adjusted.
			
			\begin{equation}
			\label{amp_sign_freq_adj}
				\rho(\phi) = - sin(2\pi\phi(t)) \in [-1, 1]
			\end{equation}
			
			For example, if a node $i$ has phase $\phi_i(t)=1/4$, it gets a value $\rho(1/4) = - sin(\pi/2) = -1$; meaning, the node's frequency should be decreased (with the highest amplitude actually) in order to "slow down" to wait for the other nodes. Conversely, if a node $j$ has phase $\phi_j(t)=3/4$, it gets a value $\rho(3/4) = - sin(3/2 \pi) = -(-1) = 1$; meaning, the node's frequency should be increased (with the highest amplitude) in order to getting "pushed forward" to catch up with the other nodes.
			
			Acts as an attenuating factor, when $\phi(t)\approx0.5$, in the making of the H-value — supporting the goal of \textit{harmonic synchrony}.

			% Om H(n)-verdiene:
			\myparagraph{Step 4: The H-value, H(n)}
			
			Describing how a node should adjust its frequency, based on the n-th ``fire-event'' it received, in the following way:
			
			\begin{equation}
			\label{h_value}
				H(n) = \rho(n) \cdot s(n)
			\end{equation}
			
			% Om selve oppdateringen av frekvens:
			\myparagraph{The final step: The Frequency Update function}
			
			Putting it all together.
			
			When an agent $i$ then has a phase-climax ($\phi_i(t)=1$), it updates its frequency to the new $\omega_i(t^+)$ accordingly:
			
			\begin{equation}
			\label{freq_adj}
				\omega_i(t^+) = \omega_i(t) \cdot 2^{F(n)},
			\end{equation}
			
			where $t^+$ denotes the time-step immediately after phase-climax, and $F(n)$ is found by:
			
			\begin{equation}
			\label{f_value}
				F(n) = \beta\sum_{x=0}^{k-1}\frac{H(n-k)}{k},
			\end{equation}
			
			where $\beta$ is the frequency coupling constant, $k$ is the number of heard/received ``fire-event''s from the start of the last cycle/period to the end (i.e. the phase-climax, or \textit{now}) — and the rest of the values are as described above.

% Om mitt bidrag (skill tydelig på mine bidrag og det jeg ikke har gjort noe med)
\section{My new proposed algorithm: an additional Self-Awareness component}
